import numpy as np


START = np.array([0.0, 0.0])
END = np.array([10.0, 10.0])


OBSTACLE = (5.0, 5.0, 1.5)

# Number of intermediate waypoints the rob hitsz
NUM_WAYPOINTS = 5
DIMENSIONS = NUM_WAYPOINTS * 2

def calculate_path_length(path):
    
    points = [START]
    for i in range(0, len(path), 2):
        points.append(np.array([path[i], path[i+1]]))
    points.append(END)
    
    length = 0.0
    for i in range(len(points) - 1):
        length += np.linalg.norm(points[i+1] - points[i])
    return length

def check_collision(p1, p2):
    """Checks if the line segment between p1 and p2 intersects the obstacle."""
    # Simplified collision check: just check if the point closest to the obstacle 
    # on the line segment is inside the obstacle's radius.
    
    center_x, center_y, radius = OBSTACLE
    obstacle_center = np.array([center_x, center_y])
    
    v = p2 - p1  # Vector from p1 to p2
    w = p1 - obstacle_center # Vector from obstacle center to p1
    
    c1 = np.dot(w, v)
    if c1 >= 0:
        # Closest point is p2 or beyond
        return np.linalg.norm(p2 - obstacle_center) < radius
    
    c2 = np.dot(v, v)
    if c1 <= -c2:
        # Closest point is p1 or before
        return np.linalg.norm(p1 - obstacle_center) < radius
    
    # Closest point is on the segment
    t = -c1 / c2
    projection = p1 + t * v
    return np.linalg.norm(projection - obstacle_center) < radius

def cost_function(path):
    
    # 1. Pth Length Cost
    length_cost = calculate_path_length(path)
    
    # 2. Collision Cost (Heavy Penalty)
    collision_penalty = 0.0
    
    points = [START]
    for i in range(0, len(path), 2):
        points.append(np.array([path[i], path[i+1]]))
    points.append(END)
    
    for i in range(len(points) - 1):
        if check_collision(points[i], points[i+1]):
            # Apply a significant penalty for each segment that collides
            collision_penalty += 1000.0
            
    # The total cost is the length plus the penalty
    return length_cost + collision_penalty

# --- 2. Particle Swarm Optimization Implementation ---

class Particle:
    def __init__(self, bounds):
        # Position is the path (a set of waypoints)
        self.position = np.random.uniform(bounds[:, 0], bounds[:, 1], size=DIMENSIONS)
        self.velocity = np.random.uniform(-1, 1, size=DIMENSIONS)
        
        # Best position found by THIS particle
        self.best_position = np.copy(self.position)
        self.best_score = cost_function(self.position)

class PSO:
    def __init__(self, cost_func, bounds, num_particles, max_iter, w=0.5, c1=1.5, c2=1.5):
        self.cost_func = cost_func
        self.bounds = bounds
        self.num_particles = num_particles
        self.max_iter = max_iter
        
        # PSO inertia and acceleration coefficients
        self.w = w  # Inertia weight
        self.c1 = c1 # Cognitive coefficient (local)
        self.c2 = c2 # Social coefficient (global)
        
        self.particles = [Particle(bounds) for _ in range(num_particles)]
        
        # Best position found by ANY particle in the swarm
        self.global_best_position = self.particles[0].best_position
        self.global_best_score = self.particles[0].best_score
        
        # Initial global best update
        for particle in self.particles:
            if particle.best_score < self.global_best_score:
                self.global_best_score = particle.best_score
                self.global_best_position = np.copy(particle.best_position)

    def optimize(self):
        for t in range(self.max_iter):
            for particle in self.particles:
                
                # Update velocity
                r1 = np.random.rand(DIMENSIONS)
                r2 = np.random.rand(DIMENSIONS)
                
                # Cognitive component (attraction to particle's own best)
                cognitive = self.c1 * r1 * (particle.best_position - particle.position)
                
                # Social component (attraction to swarm's best)
                social = self.c2 * r2 * (self.global_best_position - particle.position)
                
                # New velocity
                particle.velocity = self.w * particle.velocity + cognitive + social
                
                # Update position
                particle.position += particle.velocity
                
                # Clamp position to bounds
                for d in range(DIMENSIONS):
                    if particle.position[d] < self.bounds[d, 0]:
                        particle.position[d] = self.bounds[d, 0]
                        particle.velocity[d] *= -1 # bounce off the wall
                    if particle.position[d] > self.bounds[d, 1]:
                        particle.position[d] = self.bounds[d, 1]
                        particle.velocity[d] *= -1 # bounce off the wall

                # Evaluate new score
                current_score = self.cost_func(particle.position)
                
                # Update particle's best position
                if current_score < particle.best_score:
                    particle.best_score = current_score
                    particle.best_position = np.copy(particle.position)
                    
                    # Update global best position
                    if current_score < self.global_best_score:
                        self.global_best_score = current_score
                        self.global_best_position = np.copy(particle.best_position)
            
            # Optional: Print progress
            if (t + 1) % 10 == 0:
                print(f"Iteration {t+1}/{self.max_iter} - Best Cost: {self.global_best_score:.2f}")

        return self.global_best_position, self.global_best_score


# --- 3. Execution ---

if __name__ == '__main__':
    print("--- PSO Path Planning Simulation ---")

  
    x_bounds = [0, 10]
    y_bounds = [0, 10]
    
  
    bounds = np.zeros((DIMENSIONS, 2))
    for i in range(NUM_WAYPOINTS):
        bounds[i*2] = x_bounds  # x coordinate bounds
        bounds[i*2+1] = y_bounds # y coordinate bounds

    NUM_PARTICLES = 30
    MAX_ITER = 100

    # Initialize and run the PSO
    pso = PSO(cost_function, bounds, NUM_PARTICLES, MAX_ITER)
    best_path_vector, min_cost = pso.optimize()

    #4. Results Display 
    print("\n--- Optimization Complete ---")
    print(f"Minimum Cost (Path Length + Penalty): {min_cost:.2f}")
    
    # Reconstruct the path for display
    best_waypoints = []
    for i in range(0, len(best_path_vector), 2):
        best_waypoints.append((best_path_vector[i], best_path_vector[i+1]))
        
    print(f"Optimized Waypoints:")
    for i, (x, y) in enumerate(best_waypoints):
        print(f"  Waypoint {i+1}: ({x:.2f}, {y:.2f})")

    # Final path
    final_path = [tuple(START)] + best_waypoints + [tuple(END)]
    print("\nRobot Path (Start -> WPs -> End):")
    print(" -> ".join([f"({p[0]:.2f}, {p[1]:.2f})" for p in final_path]))
    


OUTOUT - 

import numpy as np


START = np.array([0.0, 0.0])
END = np.array([10.0, 10.0])


OBSTACLE = (5.0, 5.0, 1.5)

# Number of intermediate waypoints the rob hitsz
NUM_WAYPOINTS = 5
DIMENSIONS = NUM_WAYPOINTS * 2

def calculate_path_length(path):
    
    points = [START]
    for i in range(0, len(path), 2):
        points.append(np.array([path[i], path[i+1]]))
    points.append(END)
    
    length = 0.0
    for i in range(len(points) - 1):
        length += np.linalg.norm(points[i+1] - points[i])
    return length

def check_collision(p1, p2):
    """Checks if the line segment between p1 and p2 intersects the obstacle."""
    # Simplified collision check: just check if the point closest to the obstacle 
    # on the line segment is inside the obstacle's radius.
    
    center_x, center_y, radius = OBSTACLE
    obstacle_center = np.array([center_x, center_y])
    
    v = p2 - p1  # Vector from p1 to p2
    w = p1 - obstacle_center # Vector from obstacle center to p1
    
    c1 = np.dot(w, v)
    if c1 >= 0:
        # Closest point is p2 or beyond
        return np.linalg.norm(p2 - obstacle_center) < radius
    
    c2 = np.dot(v, v)
    if c1 <= -c2:
        # Closest point is p1 or before
        return np.linalg.norm(p1 - obstacle_center) < radius
    
    # Closest point is on the segment
    t = -c1 / c2
    projection = p1 + t * v
    return np.linalg.norm(projection - obstacle_center) < radius

def cost_function(path):
    
    # 1. Pth Length Cost
    length_cost = calculate_path_length(path)
    
    # 2. Collision Cost (Heavy Penalty)
    collision_penalty = 0.0
    
    points = [START]
    for i in range(0, len(path), 2):
        points.append(np.array([path[i], path[i+1]]))
    points.append(END)
    
    for i in range(len(points) - 1):
        if check_collision(points[i], points[i+1]):
            # Apply a significant penalty for each segment that collides
            collision_penalty += 1000.0
            
    # The total cost is the length plus the penalty
    return length_cost + collision_penalty

# --- 2. Particle Swarm Optimization Implementation ---

class Particle:
    def __init__(self, bounds):
        # Position is the path (a set of waypoints)
        self.position = np.random.uniform(bounds[:, 0], bounds[:, 1], size=DIMENSIONS)
        self.velocity = np.random.uniform(-1, 1, size=DIMENSIONS)
        
        # Best position found by THIS particle
        self.best_position = np.copy(self.position)
        self.best_score = cost_function(self.position)

class PSO:
    def __init__(self, cost_func, bounds, num_particles, max_iter, w=0.5, c1=1.5, c2=1.5):
        self.cost_func = cost_func
        self.bounds = bounds
        self.num_particles = num_particles
        self.max_iter = max_iter
        
        # PSO inertia and acceleration coefficients
        self.w = w  # Inertia weight
        self.c1 = c1 # Cognitive coefficient (local)
        self.c2 = c2 # Social coefficient (global)
        
        self.particles = [Particle(bounds) for _ in range(num_particles)]
        
        # Best position found by ANY particle in the swarm
        self.global_best_position = self.particles[0].best_position
        self.global_best_score = self.particles[0].best_score
        
        # Initial global best update
        for particle in self.particles:
            if particle.best_score < self.global_best_score:
                self.global_best_score = particle.best_score
                self.global_best_position = np.copy(particle.best_position)

    def optimize(self):
        for t in range(self.max_iter):
            for particle in self.particles:
                
                # Update velocity
                r1 = np.random.rand(DIMENSIONS)
                r2 = np.random.rand(DIMENSIONS)
                
                # Cognitive component (attraction to particle's own best)
                cognitive = self.c1 * r1 * (particle.best_position - particle.position)
                
                # Social component (attraction to swarm's best)
                social = self.c2 * r2 * (self.global_best_position - particle.position)
                
                # New velocity
                particle.velocity = self.w * particle.velocity + cognitive + social
                
                # Update position
                particle.position += particle.velocity
                
                # Clamp position to bounds
                for d in range(DIMENSIONS):
                    if particle.position[d] < self.bounds[d, 0]:
                        particle.position[d] = self.bounds[d, 0]
                        particle.velocity[d] *= -1 # bounce off the wall
                    if particle.position[d] > self.bounds[d, 1]:
                        particle.position[d] = self.bounds[d, 1]
                        particle.velocity[d] *= -1 # bounce off the wall

                # Evaluate new score
                current_score = self.cost_func(particle.position)
                
                # Update particle's best position
                if current_score < particle.best_score:
                    particle.best_score = current_score
                    particle.best_position = np.copy(particle.position)
                    
                    # Update global best position
                    if current_score < self.global_best_score:
                        self.global_best_score = current_score
                        self.global_best_position = np.copy(particle.best_position)
            
            # Optional: Print progress
            if (t + 1) % 10 == 0:
                print(f"Iteration {t+1}/{self.max_iter} - Best Cost: {self.global_best_score:.2f}")

        return self.global_best_position, self.global_best_score


# --- 3. Execution ---

if __name__ == '__main__':
    print("--- PSO Path Planning Simulation ---")

  
    x_bounds = [0, 10]
    y_bounds = [0, 10]
    
  
    bounds = np.zeros((DIMENSIONS, 2))
    for i in range(NUM_WAYPOINTS):
        bounds[i*2] = x_bounds  # x coordinate bounds
        bounds[i*2+1] = y_bounds # y coordinate bounds

    NUM_PARTICLES = 30
    MAX_ITER = 100

    # Initialize and run the PSO
    pso = PSO(cost_function, bounds, NUM_PARTICLES, MAX_ITER)
    best_path_vector, min_cost = pso.optimize()

    #4. Results Display 
    print("\n--- Optimization Complete ---")
    print(f"Minimum Cost (Path Length + Penalty): {min_cost:.2f}")
    
    # Reconstruct the path for display
    best_waypoints = []
    for i in range(0, len(best_path_vector), 2):
        best_waypoints.append((best_path_vector[i], best_path_vector[i+1]))
        
    print(f"Optimized Waypoints:")
    for i, (x, y) in enumerate(best_waypoints):
        print(f"  Waypoint {i+1}: ({x:.2f}, {y:.2f})")

    # Final path
    final_path = [tuple(START)] + best_waypoints + [tuple(END)]
    print("\nRobot Path (Start -> WPs -> End):")
    print(" -> ".join([f"({p[0]:.2f}, {p[1]:.2f})" for p in final_path]))
    


RESEARCH PAPER - https://www.mdpi.com/2218-6581/13/10/141
